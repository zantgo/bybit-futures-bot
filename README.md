# Python Trading Bot - Arquitectura de Software Avanzada

![GIF de la TUI en acci√≥n] <!-- ¬°IMPORTANTE! Graba un GIF de tu bot funcionando y ponlo aqu√≠. Es lo m√°s impactante. -->

Un bot de trading algor√≠tmico para Bybit construido en Python, enfocado en una **arquitectura modular, escalable y robusta**. Este proyecto es una demostraci√≥n pr√°ctica de principios de dise√±o de software como la Inyecci√≥n de Dependencias, el Patr√≥n Adaptador y la Separaci√≥n de Responsabilidades, todo controlado a trav√©s de una completa Interfaz de Usuario en Terminal (TUI).

> ### **Advertencia de Seguridad y Riesgo**
> **EL TRADING DE FUTUROS CON APALANCAMIENTO ES EXTREMADAMENTE RIESGOSO Y PUEDE RESULTAR EN LA P√âRDIDA TOTAL DE SU CAPITAL.**
> Este software se proporciona "tal cual", sin ninguna garant√≠a. El autor no se hace responsable de ninguna p√©rdida financiera. **Nunca** ejecute este bot en una cuenta real sin haberlo probado extensivamente en **TESTNET**.

---

## ‚ú® Caracter√≠sticas Clave

*   **Interfaz de Usuario en Terminal (TUI):** Men√∫s interactivos construidos con `simple-term-menu` para controlar el bot en tiempo real, configurar estrategias, monitorear el rendimiento y visualizar logs.
*   **Arquitectura en Capas Limpia:** Clara separaci√≥n entre la capa de Presentaci√≥n (TUI), la L√≥gica de Negocio (Estrategia) y el Acceso a Datos (API), facilitando el mantenimiento y la escalabilidad.
*   **Gesti√≥n de Estrategia Modular:** Permite configurar y ejecutar estrategias complejas (ej. promediaci√≥n de costos) con m√∫ltiples posiciones l√≥gicas, l√≠mites de riesgo (SL/TP/TSL) y condiciones de entrada/salida personalizables.
*   **Abstracci√≥n del Exchange (Patr√≥n Adaptador):** Dise√±ado con una interfaz (`AbstractExchange`) que independiza la l√≥gica del bot del exchange. La implementaci√≥n actual para Bybit (`BybitAdapter`) podr√≠a ser reemplazada o extendida para otros exchanges con un esfuerzo m√≠nimo.
*   **Manejo de Cuentas M√∫ltiples:** Orquesta operaciones y transferencias entre subcuentas dedicadas (main, longs, shorts, profit) para un aislamiento de riesgo y una gesti√≥n de capital superior.
*   **Configuraci√≥n en Caliente ("Hot Reload"):** Permite ajustar par√°metros cr√≠ticos de la estrategia (indicadores de TA, configuraci√≥n de riesgo) durante una sesi√≥n de trading activa, sin necesidad de reiniciar el bot.
*   **Logging As√≠ncrono y Detallado:** Registra se√±ales, posiciones cerradas e instant√°neas de sesi√≥n en archivos `.jsonl` para un an√°lisis y auditor√≠a posterior, sin bloquear el hilo principal.

## üõ†Ô∏è Stack Tecnol√≥gico y Principios de Dise√±o

*   **Lenguaje:** Python 3.10+
*   **Librer√≠as Principales:** `pybit`, `pandas`, `numpy`, `simple-term-menu`, `python-dotenv`
*   **Principios de Dise√±o Aplicados:**
    *   **Arquitectura Limpia (Clean Architecture):** Flujo de dependencias claro hacia el n√∫cleo del negocio.
    *   **Inyecci√≥n de Dependencias (DI):** Las clases reciben sus dependencias en lugar de crearlas, lo que facilita las pruebas y la modularidad.
    *   **Patr√≥n Fachada (Facade):** M√≥dulos `_api.py` que exponen una interfaz simple para subsistemas complejos (PM, OM, SM).
    *   **Patr√≥n Adaptador (Adapter):** La capa `core/exchange` que desacopla el bot de la implementaci√≥n espec√≠fica de Bybit.
    *   **Separaci√≥n de Responsabilidades (SoC):** Cada clase y m√≥dulo tiene un prop√≥sito bien definido (ej. `PositionExecutor` solo ejecuta, `_calculator` solo calcula).

## üìê Arquitectura y Modelo de Datos

Este proyecto no es solo un script, sino un sistema de software dise√±ado con una arquitectura en capas bien definida. Los siguientes diagramas ilustran la estructura, el flujo de datos y las relaciones entre los componentes clave.

### 1. Diagrama de Arquitectura de Capas

Este diagrama muestra la visi√≥n de alto nivel del sistema, organizado seg√∫n los principios de **Arquitectura Limpia (Clean Architecture)**. Cada capa tiene una responsabilidad clara, y las dependencias fluyen hacia el interior (hacia la l√≥gica de negocio), lo que hace que el sistema sea modular, comprobable y f√°cil de mantener.

```mermaid
graph TD
    subgraph "Capa de Presentaci√≥n"
        TUI["üíª Interfaz de Usuario en Terminal (TUI)"]
    end

    subgraph "Capa de Control de Aplicaci√≥n"
        BotController["ü§ñ BotController (Gestor Principal)"]
        SessionManager["üìà SessionManager (Gestor de Sesi√≥n)"]
    end

    subgraph "Capa de L√≥gica de Negocio (Estrategia)"
        OM["üß† OperationManager (OM)"]
        PM["üìä PositionManager (PM)"]
        TA_Signal["üî¨ TA Manager & Signal Generator"]
    end

    subgraph "Capa de Abstracci√≥n del Exchange"
        style Adapter fill:#f9f,stroke:#333,stroke-width:2px
        Adapter["üîå BybitAdapter (Traductor)"]
    end

    subgraph "Capa de Infraestructura"
        API["üì° core/api & ConnectionManager"]
        Bybit["üè¶ Exchange (Bybit API)"]
    end

    %% --- Conexiones y Flujo de Control ---
    TUI -- "Acciones del Usuario" --> BotController
    BotController -- "Crea/Inicia Sesi√≥n" --> SessionManager
    SessionManager -- "Orquesta Eventos de Precio" --> TA_Signal
    SessionManager -- "Pasa Se√±ales y Ticks" --> PM
    OM -- "Define Estrategia y Estado" --> PM
    TA_Signal -- "Genera Se√±al (BUY/SELL)" --> PM
    PM -- "Ejecuta Orden (Abrir/Cerrar)" --> Adapter
    Adapter -- "Traduce a llamada API" --> API
    API -- "Comunica con" --> Bybit
```

### 2. Diagrama de Flujo de Datos (Ciclo de Vida de un Tick)

Este diagrama de secuencia ilustra la **interacci√≥n din√°mica** entre los componentes clave cuando se recibe un nuevo tick de precio. Muestra paso a paso c√≥mo la informaci√≥n fluye a trav√©s del sistema, desde la obtenci√≥n del precio hasta la posible ejecuci√≥n de una orden.

```mermaid
sequenceDiagram
    participant Ticker
    participant SessionManager as SM
    participant EventProcessor as EP
    participant TAManager as TA
    participant SignalGenerator as Signal
    participant PositionManager as PM
    participant ExchangeAdapter as Adapter

    loop Cada 'N' segundos
        Ticker->>SM: 1. Nuevo Precio Obtenido
        SM->>EP: 2. Procesa Evento de Precio
        
        EP->>TA: 3. A√±ade Tick y Calcula Indicadores
        TA-->>EP: 4. Devuelve Indicadores (EMA, etc.)
        
        EP->>Signal: 5. Eval√∫a Indicadores con Reglas
        Signal-->>EP: 6. Devuelve Se√±al (BUY/SELL/HOLD)
        
        EP->>PM: 7. Notifica Se√±al y Precio Actual
        
        alt La se√±al es BUY/SELL y las condiciones se cumplen
            PM->>Adapter: 8. Orden de Apertura (StandardOrder)
            Adapter-->>PM: 9. Respuesta de la API
        end

        alt Las condiciones de SL/TSL se cumplen
            PM->>Adapter: 8. Orden de Cierre (StandardOrder)
            Adapter-->>PM: 9. Respuesta de la API
        end
    end
```

### 3. Modelo de Clases (Diagrama de Clases UML Simplificado)

Este diagrama muestra las **clases m√°s importantes** del sistema y sus relaciones (composici√≥n, herencia, asociaci√≥n). Refleja la estructura orientada a objetos del proyecto y c√≥mo las responsabilidades se encapsulan en diferentes clases.

```mermaid
classDiagram
    direction LR

    class BotController {
        +create_session() SessionManager
        +run_position_test()
    }

    class SessionManager {
        -ticker : Ticker
        -event_processor : EventProcessor
        +start()
        +stop()
    }

    class OperationManager {
        -long_operation : Operacion
        -short_operation : Operacion
        +create_or_update_operation()
        +pausar_operacion()
    }

    class PositionManager {
        -executor : PositionExecutor
        +handle_low_level_signal()
        +check_and_close_positions()
    }
    
    class AbstractExchange {
        <<Interface>>
        +place_order()
        +get_ticker()
    }

    class BybitAdapter {
        +place_order(StandardOrder)
        +get_ticker(symbol)
    }

    class Ticker {
        +start(callback)
    }
    
    class EventProcessor {
      +process_event()
    }

    %% --- Relaciones Estructurales ---
    BotController "1" *-- "1" SessionManager : crea
    SessionManager "1" *-- "1" Ticker : gestiona
    SessionManager "1" *-- "1" EventProcessor : orquesta
    SessionManager "1" *-- "1" OperationManager : gestiona
    SessionManager "1" *-- "1" PositionManager : gestiona
    
    EventProcessor ..> PositionManager : notifica
    EventProcessor ..> OperationManager : verifica
    
    PositionManager ..> OperationManager : consulta
    PositionManager --|> BybitAdapter : usa

    BybitAdapter --|> AbstractExchange : implementa
```

### 4. Modelo de Entidades de Dominio (Estructuras de Datos)

Estas son las **estructuras de datos centrales** que representan los conceptos de negocio del bot. La l√≥gica de la aplicaci√≥n opera sobre estas entidades, que se mantienen desacopladas de cualquier detalle de implementaci√≥n externa.

*   **`Operacion`**: Representa una estrategia completa para un lado del mercado (LONG o SHORT). Contiene toda la configuraci√≥n de la estrategia y la lista de sus posiciones.
*   **`LogicalPosition`**: Representa un "lote" de capital individual que puede ser invertido. Es la unidad at√≥mica de trading que el `PositionManager` gestiona.

```mermaid
classDiagram
    class Operacion {
        +id : str
        +estado : str
        +apalancamiento : float
        +averaging_distance_pct : float
        +roi_sl : dict
        +posiciones : List<LogicalPosition>
    }

    class LogicalPosition {
        +id : str
        +estado : str ('PENDIENTE', 'ABIERTA')
        +capital_asignado : float
        +entry_price : float
        +size_contracts : float
        +stop_loss_price : float
    }

    Operacion "1" *-- "0..*" LogicalPosition : contiene
```

## üöÄ Puesta en Marcha

Sigue estos pasos para configurar y ejecutar el bot en tu m√°quina local.

### 1. Prerrequisitos
-   Python 3.10 o superior.
-   Una cuenta en [Bybit](https://www.bybit.com/).

### 2. Instalaci√≥n
1.  **Clonar el repositorio:**
    ```bash
    git clone https://github.com/zantgo/bybit-futures-bot-67.git
    cd tu-repositorio
    ```

2.  **Crear y activar un entorno virtual:**
    ```bash
    python -m venv venv
    # En Windows:
    .\venv\Scripts\activate
    # En macOS/Linux:
    source venv/bin/activate
    ```

3.  **Instalar las dependencias:**
    ```bash
    pip install -r requirements.txt
    ```

### 3. Configuraci√≥n en Bybit y `.env`

El bot utiliza subcuentas para una gesti√≥n de riesgo aislada.

1.  **Crea Subcuentas en Bybit:**
    *   En tu panel de Bybit, ve a "Subcuentas" y crea tres subcuentas de tipo **"Cuenta de Trading Unificado"**. N√≥mbralas `longs`, `shorts`, y `profit`.
    *   Anota el **UID** de cada una de estas subcuentas.

2.  **Genera las Claves API:**
    *   **Cuenta Principal:** Crea una clave API con permisos **Leer/Escribir** para **Activos -> Transferencia**.
    *   **Subcuentas (`longs`, `shorts`, `profit`):** Para cada una, crea una clave API con permisos **Leer/Escribir** para **Contrato -> Trading Unificado**.

3.  **Configura el archivo `.env`:**
    *   Crea una copia del archivo de ejemplo: `cp .env.example .env` (o `copy .env.example .env` en Windows).
    *   Abre el archivo `.env` y rellena **todas** las variables con tus claves API y UIDs.

4.  **Deposita Fondos:**
    *   Transfiere fondos (USDT) desde tu cuenta principal a las subcuentas `longs` y `shorts` para que el bot pueda operar.

### 4. Checklist Final y Ejecuci√≥n

**¬°IMPORTANTE!** Antes de cada ejecuci√≥n, aseg√∫rate de que tu configuraci√≥n en Bybit coincide con la del bot.

*   ‚úÖ **S√≠mbolo y Capital:** Confirma que el s√≠mbolo es el correcto y que hay suficiente balance en las subcuentas `longs` y `shorts`.

*   ‚úÖ **Modo Hedge:** El bot **requiere** que el Modo Hedge est√© activado para el par que vas a operar en la plataforma de Bybit.

**Para ejecutar el bot:**
```bash
python main.py
```

## üìÇ Estructura del Proyecto

```
/
‚îú‚îÄ‚îÄ core/                # L√≥gica central del bot
‚îÇ   ‚îú‚îÄ‚îÄ api/             # Comunicaci√≥n de bajo nivel con el exchange
‚îÇ   ‚îú‚îÄ‚îÄ bot_controller/  # Orquestador principal de la aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ exchange/        # Capa de abstracci√≥n del exchange (Adapter)
‚îÇ   ‚îú‚îÄ‚îÄ logging/         # M√≥dulos de logging
‚îÇ   ‚îú‚îÄ‚îÄ menu/            # Toda la l√≥gica de la Interfaz de Usuario (TUI)
‚îÇ   ‚îî‚îÄ‚îÄ strategy/        # El coraz√≥n de la l√≥gica de trading (SM, OM, PM, TA, Signal)
‚îú‚îÄ‚îÄ connection/          # Gesti√≥n de conexiones y el Ticker de precios
‚îú‚îÄ‚îÄ runner/              # Ensamblador de dependencias y l√≥gica de apagado
‚îú‚îÄ‚îÄ config.py            # Archivo principal de configuraci√≥n de la estrategia
‚îú‚îÄ‚îÄ main.py              # Punto de entrada de la aplicaci√≥n
‚îú‚îÄ‚îÄ requirements.txt     # Dependencias del proyecto
‚îî‚îÄ‚îÄ .env.example         # Plantilla para las variables de entorno
```

## üìÑ Licencia

Este proyecto est√° bajo la Licencia MIT. Ver el archivo [LICENSE](LICENSE) para m√°s detalles.
