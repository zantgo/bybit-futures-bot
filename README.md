# Python Trading Bot - Arquitectura de Software Avanzada

![GIF de la TUI en acci√≥n] <!-- ¬°IMPORTANTE! Graba un GIF de tu bot funcionando y ponlo aqu√≠. Es lo m√°s impactante. -->

Un bot de trading algor√≠tmico para Bybit construido en Python, enfocado en una **arquitectura modular, escalable y robusta**. Este proyecto es una demostraci√≥n pr√°ctica de principios de dise√±o de software como la Inyecci√≥n de Dependencias, el Patr√≥n Adaptador y la Separaci√≥n de Responsabilidades, todo controlado a trav√©s de una completa Interfaz de Usuario en Terminal (TUI).

> ### **Advertencia de Seguridad y Riesgo**
> **EL TRADING DE FUTUROS CON APALANCAMIENTO ES EXTREMADAMENTE RIESGOSO Y PUEDE RESULTAR EN LA P√âRDIDA TOTAL DE SU CAPITAL.**
> Este software se proporciona "tal cual", sin ninguna garant√≠a. El autor no se hace responsable de ninguna p√©rdida financiera. **Nunca** ejecute este bot en una cuenta real sin haberlo probado extensivamente en **TESTNET**.

---

## ‚ú® Caracter√≠sticas Clave

*   **Interfaz de Usuario en Terminal (TUI):** Men√∫s interactivos construidos con `simple-term-menu` para controlar el bot en tiempo real, configurar estrategias, monitorear el rendimiento y visualizar logs.
*   **Arquitectura en Capas Limpia:** Clara separaci√≥n entre la capa de Presentaci√≥n (TUI), la L√≥gica de Negocio (Estrategia) y el Acceso a Datos (API), facilitando el mantenimiento y la escalabilidad.
*   **Gesti√≥n de Estrategia Modular:** Permite configurar y ejecutar estrategias complejas (ej. promediaci√≥n de costos) con m√∫ltiples posiciones l√≥gicas, l√≠mites de riesgo (SL/TP/TSL) y condiciones de entrada/salida personalizables.
*   **Abstracci√≥n del Exchange (Patr√≥n Adaptador):** Dise√±ado con una interfaz (`AbstractExchange`) que independiza la l√≥gica del bot del exchange. La implementaci√≥n actual para Bybit (`BybitAdapter`) podr√≠a ser reemplazada o extendida para otros exchanges con un esfuerzo m√≠nimo.
*   **Manejo de Cuentas M√∫ltiples:** Orquesta operaciones y transferencias entre subcuentas dedicadas (main, longs, shorts, profit) para un aislamiento de riesgo y una gesti√≥n de capital superior.
*   **Configuraci√≥n en Caliente ("Hot Reload"):** Permite ajustar par√°metros cr√≠ticos de la estrategia (indicadores de TA, configuraci√≥n de riesgo) durante una sesi√≥n de trading activa, sin necesidad de reiniciar el bot.
*   **Logging As√≠ncrono y Detallado:** Registra se√±ales, posiciones cerradas e instant√°neas de sesi√≥n en archivos `.jsonl` para un an√°lisis y auditor√≠a posterior, sin bloquear el hilo principal.

## üõ†Ô∏è Stack Tecnol√≥gico y Principios de Dise√±o

*   **Lenguaje:** Python 3.10+
*   **Librer√≠as Principales:** `pybit`, `pandas`, `numpy`, `simple-term-menu`, `python-dotenv`
*   **Principios de Dise√±o Aplicados:**
    *   **Arquitectura Limpia (Clean Architecture):** Flujo de dependencias claro hacia el n√∫cleo del negocio.
    *   **Inyecci√≥n de Dependencias (DI):** Las clases reciben sus dependencias en lugar de crearlas, lo que facilita las pruebas y la modularidad.
    *   **Patr√≥n Fachada (Facade):** M√≥dulos `_api.py` que exponen una interfaz simple para subsistemas complejos (PM, OM, SM).
    *   **Patr√≥n Adaptador (Adapter):** La capa `core/exchange` que desacopla el bot de la implementaci√≥n espec√≠fica de Bybit.
    *   **Separaci√≥n de Responsabilidades (SoC):** Cada clase y m√≥dulo tiene un prop√≥sito bien definido (ej. `PositionExecutor` solo ejecuta, `_calculator` solo calcula).


## üìê Arquitectura, Flujo y Modelos de Datos

Esta secci√≥n ofrece una inmersi√≥n profunda en el dise√±o de software y los modelos de datos que constituyen el n√∫cleo del bot. Los diagramas a continuaci√≥n no son meras ilustraciones; son una representaci√≥n precisa de los principios de **Arquitectura Limpia**, **Separaci√≥n de Responsabilidades (SoC)** y **Dise√±o Modular** que han guiado la construcci√≥n de este sistema. El objetivo es demostrar no solo una aplicaci√≥n funcional, sino una base de c√≥digo robusta, mantenible y profesional.

### 1. Arquitectura de Capas de Alto Nivel

Este diagrama ilustra la estructura de capas del bot, un pilar de la Arquitectura Limpia. El flujo de dependencias es estrictamente unidireccional (de arriba hacia abajo), apuntando siempre hacia la l√≥gica de negocio central. Este dise√±o garantiza que las capas externas (como la Interfaz de Usuario o la comunicaci√≥n con el exchange) puedan ser modificadas o reemplazadas sin afectar el n√∫cleo de la estrategia.

*   **Capa de Presentaci√≥n:** La TUI, responsable √∫nicamente de la interacci√≥n con el usuario. Delega todas las acciones a la capa de control.
*   **Capa de Control de Aplicaci√≥n:** Los "directores de orquesta" (`BotController`, `SessionManager`) que gestionan el ciclo de vida de la aplicaci√≥n y las sesiones de trading.
*   **Capa de L√≥gica de Negocio:** El cerebro del bot, donde residen las reglas de la estrategia, la gesti√≥n de operaciones (`OperationManager`) y la ejecuci√≥n de posiciones (`PositionManager`).
*   **Capa de Abstracci√≥n del Exchange:** El `BybitAdapter`, que act√∫a como un traductor (Patr√≥n Adaptador), desacoplando la l√≥gica de negocio de los detalles de implementaci√≥n de la API de Bybit.
*   **Capa de Infraestructura:** La capa m√°s externa, responsable de la comunicaci√≥n real con el exchange y la gesti√≥n de credenciales.

```mermaid
graph TD
    subgraph "Capa de Presentaci√≥n"
        TUI["üíª Interfaz de Usuario en Terminal (core/menu)"]
    end

    subgraph "Capa de Control de Aplicaci√≥n"
        BotController["ü§ñ BotController (Gestor de Aplicaci√≥n)"]
        SessionManager["üìà SessionManager (Gestor de Sesi√≥n de Trading)"]
    end

    subgraph "Capa de L√≥gica de Negocio (Estrategia)"
        OM["üß† OperationManager (Gestiona Estrategias LONG/SHORT)"]
        PM["üìä PositionManager (Gestiona Posiciones Individuales)"]
        EventProcessor["üîÑ EventProcessor (Orquestador de Ticks)"]
        TA_Signal["üî¨ TAManager & SignalGenerator"]
    end

    subgraph "Capa de Abstracci√≥n del Exchange"
        style Adapter fill:#f9f,stroke:#333,stroke-width:2px
        Adapter["üîå BybitAdapter (Traductor a Lenguaje Gen√©rico)"]
    end

    subgraph "Capa de Infraestructura"
        API["üì° core/api & ConnectionManager"]
        Pybit["üè¶ Librer√≠a Externa (pybit)"]
    end

    %% --- Flujo de Control y Dependencias ---
    TUI -- "1. Acciones del Usuario" --> BotController
    BotController -- "2. Crea Sesi√≥n" --> SessionManager
    SessionManager -- "3. Inicia Ticker y Orquesta" --> EventProcessor
    EventProcessor -- "4. Procesa tick, llama a TA/Signal" --> TA_Signal
    EventProcessor -- "5. Notifica se√±al y precio" --> PM
    OM -- "Define el estado de la Estrategia" --> PM
    TA_Signal -- "Genera Se√±al (BUY/SELL)" --> PM
    PM -- "Decide Abrir/Cerrar y ordena a" --> Adapter
    Adapter -- "Traduce y utiliza" --> API
    API -- "Construye y env√≠a petici√≥n" --> Pybit
```

### 2. Flujo de Datos: El Ciclo de Vida de un Tick de Precio

Este diagrama de secuencia ilustra el comportamiento din√°mico del sistema en tiempo real. Muestra, paso a paso, c√≥mo un simple evento de precio fluye a trav√©s de las capas para ser analizado y, potencialmente, desencadenar una acci√≥n de trading. Este flujo demuestra la orquestaci√≥n y la colaboraci√≥n entre los componentes clave.

1.  El `Ticker` obtiene el precio y lo env√≠a al `SessionManager`.
2.  El `SessionManager` delega el evento al `EventProcessor`, el orquestador central de la l√≥gica de tick.
3.  El `EventProcessor` realiza el "Heartbeat de Seguridad", pidiendo al `PositionManager` que verifique la existencia de posiciones en el exchange.
4.  Luego, pasa el precio al `TAManager` para el c√°lculo de indicadores.
5.  Los indicadores actualizados son enviados al `SignalGenerator` para evaluar las reglas de la estrategia.
6.  La se√±al resultante (`BUY`/`SELL`/`HOLD`) es enviada al `PositionManager` para que eval√∫e si debe actuar.
7.  Si se cumplen todas las condiciones (operaci√≥n activa, distancia de promediaci√≥n, etc.), el `PositionManager` ordena la ejecuci√≥n a trav√©s del `ExchangeAdapter`.

```mermaid
sequenceDiagram
    participant Ticker
    participant SessionManager as SM
    participant EventProcessor as EP
    participant PositionManager as PM
    participant TAManager as TA
    participant SignalGenerator as Signal
    participant ExchangeAdapter as Adapter

    loop Cada 'N' segundos
        Ticker->>SM: 1. Nuevo Precio Obtenido
        SM->>EP: 2. Procesa Evento de Precio
        
        EP->>PM: 3. Heartbeat: sync_physical_positions()
        
        EP->>TA: 4. process_raw_price_event()
        TA-->>EP: 5. Devuelve Indicadores (EMA, etc.)
        
        EP->>Signal: 6. generate_signal()
        Signal-->>EP: 7. Devuelve Se√±al (BUY/SELL/HOLD)
        
        EP->>PM: 8. handle_low_level_signal()
        
        alt Se√±al es BUY y PM valida condiciones
            PM->>Adapter: 9. place_order(StandardOrder)
            Adapter-->>PM: 10. Respuesta de la API
        end
    end
```

### 3. Diagrama de Clases: Relaciones entre Componentes Clave

Este diagrama de clases UML modela las relaciones estructurales entre los principales gestores y componentes del sistema. Ilustra la **Inyecci√≥n de Dependencias** y la composici√≥n que definen la arquitectura.

*   **Composici√≥n (`*--`):** Muestra relaciones de propiedad fuerte. Por ejemplo, el `BotController` **crea y posee** una instancia de `SessionManager`. A su vez, el `SessionManager` **posee** al `Ticker` y al `EventProcessor`.
*   **Agregaci√≥n (`o--`):** Muestra relaciones de "tiene un". El `SessionManager` **tiene acceso a** `OperationManager` y `PositionManager`, pero no es su propietario exclusivo.
*   **Dependencia (`..>`):** Muestra relaciones de "utiliza un". El `PositionManager` **utiliza** al `OperationManager` para consultar el estado de la estrategia y al `BybitAdapter` para ejecutar √≥rdenes.

```mermaid
classDiagram
    class BotController {
        <<Manager Principal>>
        -dependencies: Dict
        +create_session(): SessionManager
        +initialize_connections()
    }
    class SessionManager {
        <<Gestor de Sesi√≥n>>
        -ticker: Ticker
        -eventProcessor: EventProcessor
        -pm: PositionManager
        -om: OperationManager
        +start()
        +stop()
        +update_session_parameters()
    }
    class OperationManager {
        <<Gestor de Estrategia>>
        -long_operation: Operacion
        -short_operation: Operacion
        +get_operation_by_side(): Operacion
        +pausar_operacion()
        +detener_operacion()
    }
    class PositionManager {
        <<Gestor de Posiciones>>
        -executor: PositionExecutor
        -om_api: OperationManagerAPI
        +handle_low_level_signal()
        +check_and_close_positions()
        +manual_open_next_pending_position()
    }
    class EventProcessor {
        <<Orquestador de Ticks>>
        -taManager: TAManager
        -signalGenerator: SignalGenerator
        +process_event()
    }
    class Ticker {
        <<Infraestructura>>
        -thread: Thread
        +start()
    }
    class BybitAdapter {
        <<Adaptador>>
        +place_order(StandardOrder)
        +get_positions(): List~StandardPosition~
    }
    class Operacion {
        <<Entidad de Dominio>>
    }

    BotController "1" *-- "1" SessionManager : crea
    SessionManager "1" *-- "1" Ticker : contiene
    SessionManager "1" *-- "1" EventProcessor : contiene
    SessionManager "1" o-- "1" OperationManager : utiliza
    SessionManager "1" o-- "1" PositionManager : utiliza
    
    EventProcessor ..> TAManager : depende de
    EventProcessor ..> SignalGenerator : depende de
    
    PositionManager ..> OperationManager : consulta estado v√≠a API
    PositionManager ..> BybitAdapter : ejecuta a trav√©s de

    OperationManager "1" *-- "2" Operacion : gestiona
```

### 4. Modelo de Entidades de Dominio (ERD)

Este diagrama se centra exclusivamente en las **estructuras de datos** que definen la l√≥gica de negocio del bot, ubicadas en `core/strategy/entities`. Muestra c√≥mo se modela una estrategia de trading.

*   **`SessionManager`:** Aunque es un gestor de procesos, act√∫a como el **contenedor de contexto** para las dos operaciones principales de una sesi√≥n de trading. No es una entidad de datos persistente, sino el orquestador en tiempo de ejecuci√≥n.
*   **`Operacion`:** Es la entidad central que representa una **estrategia completa y configurable** para un lado del mercado (ej. la estrategia de promediaci√≥n en LONG). Contiene todos los par√°metros de alto nivel, los l√≠mites de riesgo de la operaci√≥n y el estado general (`ACTIVA`, `PAUSADA`, etc.).
*   **`LogicalPosition`:** Representa una **unidad individual de capital y riesgo**. Es el "lote" que se abre y se cierra en el mercado. Tiene su propio estado (`PENDIENTE`, `ABIERTA`), precio de entrada, y par√°metros de riesgo individuales como el Stop Loss.

La relaci√≥n clave es que una `SessionManager` gestiona dos `Operacion`es, y cada `Operacion` a su vez contiene una o m√°s `LogicalPosition`. Esta estructura es la que permite la implementaci√≥n de estrategias complejas como la promediaci√≥n de costos.

```mermaid
classDiagram
    direction LR
    
    class SessionManager {
        <<Gestor de Sesi√≥n>>
        +session_start_time: datetime
        +is_running: bool
    }

    class Operacion {
        <<Entidad de Estrategia>>
        +id: str
        +estado: str {"ACTIVA", "PAUSADA", "DETENIDA"}
        +tendencia: str {"LONG_ONLY", "SHORT_ONLY"}
        +apalancamiento: float
        +pnl_realizado_usdt: float
        +capital_inicial_usdt: float
        +roi_sl: Dict
        +roi_tp: Dict
        +...
    }
    class LogicalPosition {
        <<Entidad de Posici√≥n>>
        +id: str
        +estado: str {"PENDIENTE", "ABIERTA"}
        +capital_asignado: float
        +entry_price: float
        +size_contracts: float
        +stop_loss_price: float
        +ts_is_active: bool
        +...
    }
    
    SessionManager "1" *-- "2" Operacion : gestiona
    Operacion "1" *-- "1..*" LogicalPosition : contiene```
## üöÄ Puesta en Marcha

Sigue estos pasos para configurar y ejecutar el bot en tu m√°quina local.

### 1. Prerrequisitos
-   Python 3.10 o superior.
-   Una cuenta en [Bybit](https://www.bybit.com/).

### 2. Instalaci√≥n
1.  **Clonar el repositorio:**
    ```bash
    git clone https://github.com/zantgo/bybit-futures-bot-67.git
    cd tu-repositorio
    ```

2.  **Crear y activar un entorno virtual:**
    ```bash
    python -m venv venv
    # En Windows:
    .\venv\Scripts\activate
    # En macOS/Linux:
    source venv/bin/activate
    ```

3.  **Instalar las dependencias:**
    ```bash
    pip install -r requirements.txt
    ```

### 3. Configuraci√≥n en Bybit y `.env`

El bot utiliza subcuentas para una gesti√≥n de riesgo aislada.

1.  **Crea Subcuentas en Bybit:**
    *   En tu panel de Bybit, ve a "Subcuentas" y crea tres subcuentas de tipo **"Cuenta de Trading Unificado"**. N√≥mbralas `longs`, `shorts`, y `profit`.
    *   Anota el **UID** de cada una de estas subcuentas.

2.  **Genera las Claves API:**
    *   **Cuenta Principal:** Crea una clave API con permisos **Leer/Escribir** para **Activos -> Transferencia**.
    *   **Subcuentas (`longs`, `shorts`, `profit`):** Para cada una, crea una clave API con permisos **Leer/Escribir** para **Contrato -> Trading Unificado**.

3.  **Configura el archivo `.env`:**
    *   Crea una copia del archivo de ejemplo: `cp .env.example .env` (o `copy .env.example .env` en Windows).
    *   Abre el archivo `.env` y rellena **todas** las variables con tus claves API y UIDs.

4.  **Deposita Fondos:**
    *   Transfiere fondos (USDT) desde tu cuenta principal a las subcuentas `longs` y `shorts` para que el bot pueda operar.

### 4. Checklist Final y Ejecuci√≥n

**¬°IMPORTANTE!** Antes de cada ejecuci√≥n, aseg√∫rate de que tu configuraci√≥n en Bybit coincide con la del bot.

*   ‚úÖ **S√≠mbolo y Capital:** Confirma que el s√≠mbolo es el correcto y que hay suficiente balance en las subcuentas `longs` y `shorts`.

*   ‚úÖ **Modo Hedge:** El bot **requiere** que el Modo Hedge est√© activado para el par que vas a operar en la plataforma de Bybit.

**Para ejecutar el bot:**
```bash
python main.py
```

## üìÇ Estructura del Proyecto

```
/
‚îú‚îÄ‚îÄ core/                # L√≥gica central del bot
‚îÇ   ‚îú‚îÄ‚îÄ api/             # Comunicaci√≥n de bajo nivel con el exchange
‚îÇ   ‚îú‚îÄ‚îÄ bot_controller/  # Orquestador principal de la aplicaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ exchange/        # Capa de abstracci√≥n del exchange (Adapter)
‚îÇ   ‚îú‚îÄ‚îÄ logging/         # M√≥dulos de logging
‚îÇ   ‚îú‚îÄ‚îÄ menu/            # Toda la l√≥gica de la Interfaz de Usuario (TUI)
‚îÇ   ‚îî‚îÄ‚îÄ strategy/        # El coraz√≥n de la l√≥gica de trading (SM, OM, PM, TA, Signal)
‚îú‚îÄ‚îÄ connection/          # Gesti√≥n de conexiones y el Ticker de precios
‚îú‚îÄ‚îÄ runner/              # Ensamblador de dependencias y l√≥gica de apagado
‚îú‚îÄ‚îÄ config.py            # Archivo principal de configuraci√≥n de la estrategia
‚îú‚îÄ‚îÄ main.py              # Punto de entrada de la aplicaci√≥n
‚îú‚îÄ‚îÄ requirements.txt     # Dependencias del proyecto
‚îî‚îÄ‚îÄ .env.example         # Plantilla para las variables de entorno
```

## üìÑ Licencia

Este proyecto est√° bajo la Licencia MIT. Ver el archivo [LICENSE](LICENSE) para m√°s detalles.
